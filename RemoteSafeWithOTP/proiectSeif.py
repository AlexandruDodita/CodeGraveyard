# main.py on Raspberry Pi Pico W (with Bluetooth OTP - Rebased on working web server)import networkimport socketimport timefrom machine import Pin, PWM, UARTimport urandom  # For OTP generation# --- Configuration ---WIFI_SSID = "YOUR_WIFI_SSID"  # Replace with your WiFi SSIDWIFI_PASSWORD = "YOUR_WIFI_PASSWORD"  # Replace with your WiFi PasswordSERVO_PIN = 16  # GPIO pin for servo# Safe and Servo ConfigurationANGLE_OPEN = 180ANGLE_CLOSED = 90# Servo PWM parametersMIN_DUTY = 1600MAX_DUTY = 8200PWM_FREQ = 50# Bluetooth/UART ConfigurationUART_ID = 0UART_BAUDRATE = 9600UART_TX_PIN = Pin(0)UART_RX_PIN = Pin(1)BT_COMMAND_HELLO = "HELLO"# OTP ConfigurationOTP_LIFETIME_SECONDS = 60  # OTP valid for 60 secondsOTP_LENGTH = 6# --- Global Variables ---pwm = PWM(Pin(SERVO_PIN))pwm.freq(PWM_FREQ)uart = Noneuart_buffer = b''safe_is_open = Falsetransient_feedback_message = ""current_otp = ""last_otp_generation_time = 0# --- Functions ---def init_uart():    """Initialize UART for Bluetooth communication"""    global uart    try:        uart = UART(UART_ID, baudrate=UART_BAUDRATE, tx=UART_TX_PIN, rx=UART_RX_PIN)    print(f"UART {UART_ID} initialized at {UART_BAUDRATE} baud.")    except Exception as e:    print(f"Error initializing UART: {e}")    uart = Nonedef set_servo_angle(angle):    """Set servo to specified angle and update safe state"""    global safe_is_open    if not 0 <= angle <= 180:        print(f"Angle {angle} out of range (0-180)")    return    duty = int(MIN_DUTY + (angle / 180) * (MAX_DUTY - MIN_DUTY))    pwm.duty_u16(duty)    print(f"Servo set to angle: {angle} degrees, duty: {duty}")    if angle == ANGLE_OPEN:        safe_is_open = True    elif angle == ANGLE_CLOSED:        safe_is_open = False    time.sleep_ms(500)def connect_wifi(ssid, password):    """Connect to WiFi and return IP address"""    wlan = network.WLAN(network.STA_IF)    wlan.active(True)    if not wlan.isconnected():        print('Connecting to WiFi...')    wlan.connect(ssid, password)    timeout = 15    start_time = time.time()    while not wlan.isconnected() and (time.time() - start_time) < timeout:        print('.', end='')        time.sleep(1)    print()    if wlan.isconnected():        ip_address = wlan.ifconfig()[0]    print(f'Connected! Pico IP Address: {ip_address}')    return ip_address    else:    print('Failed to connect to WiFi.')    return Nonedef parse_query_params(query_string):    """Parse URL query parameters"""    params = {}    if query_string:        pairs = query_string.split('&')    for pair in pairs:        if '=' in pair:            key, value_raw = pair.split('=', 1)        # Basic URL decoding for common characters        value = value_raw.replace('%20', ' ').replace('%21', '!').replace('%23', '#')        value = value.replace('%24', '$').replace('%25', '%').replace('%26', '&')        value = value.replace('%2B', '+').replace('%2C', ',').replace('%2F', '/')        value = value.replace('%3A', ':').replace('%3B', ';').replace('%3D', '=')        value = value.replace('%3F', '?').replace('%40', '@')        params[key] = value        else:        params[pair] = ''    return paramsdef generate_html_page(is_currently_open, feedback_msg):    """Generate the HTML page for the web interface"""    status_text = "Safe is OPEN" if is_currently_open else "Safe is CLOSED"    status_class = "open" if is_currently_open else "closed"    feedback_html = ""    if feedback_msg:        feedback_html = f'<div class="message">{feedback_msg}</div>'    html = f"""<!DOCTYPE html><html lang="en"><head>	<meta charset="UTF-8">	<title>Pico Safe Control - OTP</title>	<meta name="viewport" content="width=device-width, initial-scale=1.0">	<style>    	body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #2C2F33; color: #FFFFFF; display: flex; justify-content: center; align-items: center; min-height: 90vh; text-align: center; }}    	.container {{ background-color: #23272A; padding: 25px 30px; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); display: inline-block; max-width: 420px; width: 90%; }}    	h1 {{ color: #7289DA; margin-top: 0; margin-bottom: 25px; font-size: 2em; }}    	.status {{ font-size: 1.3em; margin-bottom: 25px; padding: 12px; border-radius: 6px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }}    	.status.closed {{ background-color: #C0392B; border: 1px solid #A93226; color: #FFFFFF; }}    	.status.open {{ background-color: #2ECC71; border: 1px solid #27AE60; color: #1E1F22; }}    	.controls form {{ margin-bottom: 20px; }}    	.controls label {{ display: block; margin-bottom: 8px; color: #99AAB5; text-align: left; font-weight: 500;}}    	.controls input[type="password"], .controls input[type="text"] {{        	padding: 12px; width: calc(100% - 26px); margin-bottom: 15px; border: 1px solid #4F545C; border-radius: 5px; background-color: #40444B; color: #DCDDDE; font-size: 1em;    	}}    	.controls input[type="submit"], .controls button {{        	padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1.1em; font-weight: bold; width: 100%;        	transition: background-color 0.2s ease, transform 0.1s ease;    	}}    	.controls input[type="submit"]:active, .controls button:active {{ transform: scale(0.98); }}    	.button-open {{ background-color: #57F287; color: #1E1F22; }}    	.button-open:hover {{ background-color: #4ACE7B; }}    	.button-close {{ background-color: #ED4245; color: white; margin-top: 10px; }}    	.button-close:hover {{ background-color: #D83639; }}    	.message {{ margin-top: 20px; padding: 10px 15px; border-radius: 5px; font-weight: bold; background-color: #FAA61A; color: #23272A;}}    	.message:empty {{ display: none; }}    	.otp-info {{ margin-bottom: 15px; padding: 10px; background-color: #3A3E42; border-radius: 5px; color: #B9BBBE; font-size: 0.9em; }}	</style></head><body>	<div class="container">    	<h1>Digital Safe Lock</h1>    	<div class="status {status_class}">{status_text}</div>    	<div class="otp-info">        	üì± Check your Bluetooth device for the current OTP<br>        	‚è±Ô∏è OTP refreshes every {OTP_LIFETIME_SECONDS} seconds    	</div>    	<div class="controls">        	<form action="/process_action" method="get" accept-charset="UTF-8">            	<input type="hidden" name="action" value="open">            	<label for="password">Enter OTP from Bluetooth:</label>            	<input type="password" id="password" name="password" required placeholder="Enter 6-digit OTP" maxlength="6">            	<input type="submit" value="Unlock Safe" class="button-open">        	</form>        	<form action="/process_action" method="get" accept-charset="UTF-8">            	<input type="hidden" name="action" value="close">            	<input type="submit" value="Lock Safe" class="button-close">        	</form>    	</div>    	{feedback_html}	</div></body></html>"""    return htmldef generate_and_send_otp():    """Generate new OTP and send via Bluetooth"""    global current_otp, last_otp_generation_time    # Generate 6-digit OTP    otp_digits = [str(urandom.randint(0, 9)) for _ in range(OTP_LENGTH)]    current_otp = "".join(otp_digits)    last_otp_generation_time = time.ticks_ms()    print(f"NEW OTP Generated: {current_otp}")    # Send via Bluetooth if available    if uart:        try:            uart.write(f"OTP: {current_otp}\n")            print(f"OTP sent to Bluetooth: {current_otp}")        except Exception as e:            print(f"Error sending OTP via Bluetooth: {e}")        else:            print("Bluetooth not available - OTP not sent")def check_for_bluetooth_commands():    """Check for incoming Bluetooth commands"""    global uart_buffer    if not uart or not uart.any():        return    try:        byte = uart.read(1)    if byte:        uart_buffer += byte        # Process complete lines        if uart_buffer.endswith(b'\n'):            command_line = uart_buffer.decode('utf-8').strip()        uart_buffer = b''        print(f"BT Command: '{command_line}'")        if command_line == BT_COMMAND_HELLO:            uart.write("Pico: Hello World!\n")        elif command_line == "NEWOTP":            generate_and_send_otp()            uart.write("Pico: New OTP generated\n")        else:            uart.write(f"Pico: Unknown command '{command_line}'\n")        # Prevent buffer overflow        elif len(uart_buffer) > 128:        uart_buffer = b''    except Exception as e:    print(f"Error processing Bluetooth: {e}")    uart_buffer = b''def start_web_server(ip_address):    """Start the web server with non-blocking socket to allow continuous OTP timing"""    global transient_feedback_message    if not ip_address:        return    addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]    s = socket.socket()    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    try:        s.bind(addr)    except OSError as e:        print(f"Error binding socket: {e}. Is another server running on port 80?")    return    s.listen(1)    s.setblocking(False)  # Make socket non-blocking    print(f'Web server listening on http://{ip_address}')    while True:    # First, always check for OTP regeneration and Bluetooth    current_time_ms = time.ticks_ms()    if time.ticks_diff(current_time_ms, last_otp_generation_time) >= (OTP_LIFETIME_SECONDS * 1000):        generate_and_send_otp()    check_for_bluetooth_commands()    # Then check for web requests (non-blocking)    cl = None    try:        cl, addr_info = s.accept()        cl.setblocking(True)  # Make client socket blocking for request handling        print('Client connected from', addr_info)        request_bytes = cl.recv(1024)        request_str = request_bytes.decode('utf-8')        first_line = request_str.split('\r\n', 1)[0]        parts = first_line.split(' ')        if len(parts) < 2:            response = 'HTTP/1.1 400 Bad Request\r\nContent-Length: 0\r\nConnection: close\r\n\r\n'        cl.sendall(response.encode('utf-8'))        cl.close()        continue        method = parts[0]        full_path = parts[1]        path, query_string = (full_path.split('?', 1) + [''])[:2]        action_feedback_for_this_request = ""        if method == "GET" and path == "/process_action":            params = parse_query_params(query_string)        action = params.get("action")        submitted_password = params.get("password", "")        if action == "open":            print(f"OTP Check: Submitted='{submitted_password}' vs Expected='{current_otp}'")            if submitted_password == current_otp and current_otp != "":                set_servo_angle(ANGLE_OPEN)            action_feedback_for_this_request = "Safe Unlocked with OTP!"            elif current_otp == "":            action_feedback_for_this_request = "OTP not yet generated. Please wait."            else:            action_feedback_for_this_request = "Incorrect OTP! Check Bluetooth for current code."        elif action == "close":            set_servo_angle(ANGLE_CLOSED)            action_feedback_for_this_request = "Safe Locked."        transient_feedback_message = action_feedback_for_this_request        response = 'HTTP/1.1 303 See Other\r\nLocation: /\r\nConnection: close\r\n\r\n'        cl.sendall(response.encode('utf-8'))        elif method == "GET" and path == "/":        current_page_html = generate_html_page(safe_is_open, transient_feedback_message)        transient_feedback_message = ""        response = f'HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=UTF-8\r\nContent-Length: {len(current_page_html)}\r\nConnection: close\r\n\r\n{current_page_html}'        cl.sendall(response.encode('utf-8'))        elif "favicon.ico" in path:        response = 'HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\nConnection: close\r\n\r\n'        cl.sendall(response.encode('utf-8'))        else:        response_body = "Not Found"        response = f'HTTP/1.1 404 Not Found\r\nContent-Type: text/plain; charset=UTF-8\r\nContent-Length: {len(response_body)}\r\nConnection: close\r\n\r\n{response_body}'        cl.sendall(response.encode('utf-8'))        if cl:            cl.close()        print("Client disconnected")    except OSError as e:        # Expected for non-blocking socket when no connection is available        if e.args[0] != 11:  # EAGAIN/EWOULDBLOCK            print(f"Socket OS error: {e}")        if cl:            try:                cl.close()            except Exception:                pass    except Exception as e:        print(f"Error in web server: {e}")        if cl:            try:                cl.close()            except Exception:                pass    # Small delay to prevent busy waiting    time.sleep_ms(50)# --- Main Execution ---if __name__ == "__main__":    print("=== Digital Safe with OTP System Starting ===")    # Initialize hardware    init_uart()    set_servo_angle(ANGLE_CLOSED)    print(f"Safe initialized to CLOSED position.")    # Generate first OTP    generate_and_send_otp()    print(f"Initial OTP: {current_otp} (valid for {OTP_LIFETIME_SECONDS}s)")    # Connect to WiFi and start server    pico_ip = connect_wifi(WIFI_SSID, WIFI_PASSWORD)    if pico_ip:        print("Starting web server with OTP authentication...")    start_web_server(pico_ip)    else:    print("WiFi connection failed. Please check credentials.")    # Fallback: continue with Bluetooth-only operation    print("Running in Bluetooth-only mode...")    while True:        current_time_ms = time.ticks_ms()        if time.ticks_diff(current_time_ms, last_otp_generation_time) >= (OTP_LIFETIME_SECONDS * 1000):            generate_and_send_otp()        check_for_bluetooth_commands()        time.sleep_ms(100)